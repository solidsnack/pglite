#!/bin/bash
set -o errexit -o errtrace -o nounset -o pipefail

# Updated once for each run.
declare program= role= startd= self= sock=

function main {
  local args=()
  local name="$(name)"

  # Must be set before running `get`, below.
  self="$(self)"

  program="$(get info/etc/program)"
  role="$(get info/etc/role)"

  case "${1:-}" in
    -h)     usage ;;
    --help) usage ;;
    *)      if declare -f -- "$name" >/dev/null
            then dispatch "$name" "$@"
            else err "Function name $name must be same as basename of: $0"
            fi ;;
  esac
}

function dispatch {
  local name="$1"

  startd="$(pwd -P)"

  # Always run command in "$self".
  cd "$self"

  "$@"
}

function in_startd {(
  cd "$startd" && "$@"
)}

function ctl {
  # Note that $self is set globally, above.
  pg_ctl -D "$self"/db -l "$self"/log "$@"
}

function get {
  # Note that $self is set globally, above.
  local f="$self"/"$1"
  [[ -f $f ]] || return 1
  cat "$f"
}

function random_free_tcp_port {
  local port=16384 spacing=16
  local taken_ports=( $( netstat -aln | egrep ^tcp | fgrep LISTEN |
                         awk '{print $4}' | egrep -o '[0-9]+$' |
                         sort -n | uniq ) )

  port=$(( port + (RANDOM % spacing) ))

  for taken in "${taken_ports[@]}"
  do
    [[ $port -lt $((taken + spacing)) ]] || continue
    port=$(( taken + spacing + (RANDOM % spacing) ))
  done

  if [[ $port -ge 65535 ]]
  then err 'Could not find free port far enough away from others.'
  fi

  out "$port"
}

function token {
  if which uuidgen &>/dev/null
  then                                     # Generate true UUIDs where possible
    uuidgen | tr A-Z a-z
  else                  # When there is no `uuidgen`, just get something random
    printf '%04x%04x%04x%04x\n' $RANDOM $RANDOM $RANDOM $RANDOM
  fi
}

function t {
  date -u +%FT%TZ                                           # UTC date and time
}

function serves_on_random_tcp_port {
  local port="$(maybe get info/etc/tcp)"
  [[ $port && $port -eq 0 ]]
}

function default_socket_dir {
  out "/tmp/$program~$USER/$(get info/token)"
}

##################################################################### Utilities

function out { printf '%s\n' "$*" ;}
function msg { out "$*" >&2 ;}
function err { local x=$? ; msg "$*" ; return $(( $x == 0 ? 1 : $x )) ;}
function log { msg "$(date -u +%TZ)" "$*" ;}

# Handles "no-match" exit code specified by POSIX for filtering tools.
function maybe { "$@" || return $(( $? == 1 ? 0 : $? )) ;}

function self {( cd "$(dirname "$0")" && pwd -P )}
function name { basename "$0" ;}
