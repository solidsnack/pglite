#!/bin/bash
set -o errexit -o errtrace -o nounset -o pipefail

# Permanent settings.
declare program=pglite role=db

# Updated once for each run.
declare self= tmp=

export PGLITE_REPORTING_DIR="${PGLITE_REPORTING_DIR:-}"

function main {
  local args=()
  local name="$(name)"

  self="$(self)"
  tmp="$(tmp)"

  case "${1:-}" in
    -h)     usage ;;
    --help) usage ;;
    *)      if declare -f -- "$name" >/dev/null
            then dispatch "$name" "$@"
            else err "Function name $name must be same as basename of: $0"
            fi ;;
  esac
}

function dispatch {
  local name="$1"

  # Always run command in "$self".
  cd "$self"

  "$@"
}

function ctl {
  # Note that $self is set globally, above.
  pg_ctl -D "$self"/db -l "$self"/log "$@"
}

function get {
  # Note that $self is set globally, above.
  local f="$self"/"$1"
  [[ -f $f ]] || return 1
  cat "$f"
}

function random_free_tcp_port {
  local port=16384 spacing=16
  local taken_ports=( $( netstat -aln | egrep ^tcp | fgrep LISTEN |
                         awk '{print $4}' | egrep -o '[0-9]+$' |
                         sort -n | uniq ) )

  port=$(( port + (RANDOM % spacing) ))

  for taken in "${taken_ports[@]}"
  do
    [[ $port -lt $((taken + spacing)) ]] || continue
    port=$(( taken + spacing + (RANDOM % spacing) ))
  done

  if [[ $port -ge 65535 ]]
  then err 'Could not find free port far enough away from others.'
  fi

  out "$port"
}

function token {
  if which uuidgen &>/dev/null
  then                                     # Generate true UUIDs where possible
    uuidgen | tr A-Z a-z
  else                  # When there is no `uuidgen`, just get something random
    printf '%04x%04x%04x%04x\n' $RANDOM $RANDOM $RANDOM $RANDOM
  fi
}

function t {
  date -u +%FT%TZ                                           # UTC date and time
}

function serves_on_random_tcp_port {
  local port="$(maybe get info/etc/tcp)"
  [[ $port && $port -eq 0 ]]
}

function tmp {
  out "/tmp/.$program.$(get info/token)"       # TODO: Query for system tmp dir
}

##################################################################### Utilities

function out { printf '%s\n' "$*" ;}
function msg { out "$*" >&2 ;}
function err { local x=$? ; msg "$*" ; return $(( $x == 0 ? 1 : $x )) ;}
function log { msg "$(date -u +%TZ)" "$*" ;}

# Handles "no-match" exit code specified by POSIX for filtering tools.
function maybe { "$@" || return $(( $? == 1 ? 0 : $? )) ;}

function self {( cd "$(dirname "$0")" && pwd -P )}
function name { basename "$0" ;}
