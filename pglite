#!/bin/bash
set -o errexit -o nounset -o pipefail
function -h {
cat <<USAGE
 USAGE: pglite (-p|--personality <personality>)? (-d|--directory <path>)?
        pglite setup (-p|--personality <personality>)? (-d|--directory <path>)?
        pglite url (-d|--directory <path>)?
        pglite start|stop|status (-d|--directory <path>)?
        pglite connect (-d|--directory <path>)?
        pglite rm (-d|--directory <path>)?

  Creates and manages the lifecycle of a Postgres database, using the system
  server installation.

  This is intended to facilitate embedded applications, ephemeral database for
  data processing applications, and testing.

 pglite setup

  Create the database directory.

 pglite url

  Obtain the Postgres URL for connecting (always a UNIX socket-based URL).

 pglite start|stop|status

  Start, stop or poll the status of the server.

 pglite connect

  Connect to the database, starting the server if it's not already started.

 pglite rm

  Remove the database directory and its configuration.

 -p|--personality pipeline|postgres

  Defaults to \`postgres\`. The \`pipeline\` personality exists to support
  PipelineDB.

 -d|--directory /path/to/data

  Defaults to \`$root\`.

USAGE
}; function --help { -h ;}                 # A nice way to handle -h and --help
export LC_ALL=en_US.UTF-8                    # A locale that works consistently

args=()
root=tmp/pglite
admin="$(whoami)"
role=lite

function main {
  local args=() personality=postgres
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      start|stop|status) args+=( ctl "$1" ) ;;
      rm)                args+=( clean ) ;;
      -p|--personality)  personality="$2" ; shift ;;
      -d|--directory)    root="$2" ; shift ;;
      *)                 args+=( "$1" ) ;;
      --)                args+=( "$@" ) ; break ;;
    esac
    shift
  done

  set_personality "$personality"

  if [[ ${#args[@]} -gt 0 ]]
  then "${args[@]}"
  else setup && connect
  fi
}

# On some systems, `pg_ctl` &al are not on the default PATH.
function path_munger {
  for bin in /usr/lib/postgresql/*/bin
  do
    [[ -d $bin ]] || continue
    export PATH="$PATH":"$bin"
    break
  done
}

path_munger

# Database personality: names of administrative commands and files.
declare ctl=false sql=false init=false conf=/dev/null

function set_personality {
  case "$1" in
    postgres)
      ctl=pg_ctl
      sql=psql
      init=initdb
      conf=postgresql.conf ;;
    pipeline)
      ctl=pipeline-ctl
      sql=pipeline
      init=pipeline-init
      conf=pipelinedb.conf ;;
    *) msg "Unrecognized personality: $1"
       err 'Please choose from: pipeline postgres'
  esac
}

function load_personality {
  if [[ -f "$root"/personality ]]
  then set_personality "$(< "$root"/personality)"
  fi
}

function setup {
  if [[ -d "$root" ]]
  then msg "NB: Skipping setup; dir exists: $root"
  else initialize
  fi
}

function connect {
  load_personality
  if ! is_running
  then
    ctl start -w
    trap finalize EXIT
  fi
  sql "$@"
}

function url {
  out "postgres://$role@[$(absroot)]/$role"
}

function absroot {
  cd "$root" && pwd -P
}

function init_cluster_directory {
  "$init" -D "$root"/db -A trust --nosync --locale en_US.UTF-8

  # Use of include_dir limits this software to PG 9.3 and above.
  if ! egrep -q "^include_dir = 'conf.d'" "$root"/db/"$conf"
  then out "include_dir = 'conf.d'" >> "$root"/db/"$conf"
  fi

  mkdir -p "$root"/db/conf.d

  base_configuration > "$root"/db/conf.d/00.pglite.conf

  out "$personality" > "$root"/personality
}

function base_configuration {
# Use of unix_socket_directories limits this software to PG 9.3 and above.
cat <<EOF
unix_socket_directories = '"$(absroot)"'
listen_addresses = ''
datestyle = 'iso, ymd'
intervalstyle = 'iso_8601'
timezone = 'UTC'
EOF
}

function init_database_and_user {
sql_admin -v ON_ERROR_STOP=on <<SQL
  CREATE ROLE "$role" WITH SUPERUSER LOGIN REPLICATION;
  CREATE DATABASE "$role" WITH OWNER "$role";
SQL
}

function ctl {
  load_personality
  "$ctl" -D "$root"/db -l "$root"/log "$@"
}

function sql {
  "$sql" -h "$(absroot)" --dbname="user=$role dbname=$role" "$@"
}

function sql_admin {
  "$sql" -h "$(absroot)" --dbname="user=$admin dbname=template1" "$@"
}

function finalize {
  local code=$?
  ctl stop -m fast 2>/dev/null || true
  kill %1 2>/dev/null || true
  exit $code
}

function initialize {
  init_cluster_directory
  trap finalize EXIT
  touch "$root"/log
  tail -qF "$root"/log &
  ctl start -w
  init_database_and_user
  kill %1
  wait %1 2>/dev/null || true
}

function is_running {
  ctl status | fgrep -q 'server is running'
}

function clean {
  msg "Removing: $root"
  [[ ! -e "$root" ]] || rm -r "$root"
}

function random_free_tcp_port {
  local ports="${1:-1}" port="${2:-2048}" spacing=32
  local free_ports=( )
  local taken_ports=( $( netstat -aln | egrep ^tcp | fgrep LISTEN |
                         awk '{print $4}' | egrep -o '[0-9]+$' |
                         sort -n | uniq ) )

  port=$(( port + (RANDOM % spacing) ))

  for taken in "${taken_ports[@]}" 65535
  do
    while [[ $port -lt $taken && ${#free_ports[@]} -lt $ports ]]
    do
      free_ports+=( $port )
      port=$(( port + spacing + (RANDOM % spacing) ))
    done
    if [[ $port -lt $((taken + spacing)) ]]
    then port=$(( taken + spacing + (RANDOM % spacing) ))
    fi
  done

  [[ ${#free_ports[@]} -ge $ports ]] || return 2

  printf '%d\n' "${free_ports[@]}"
}


##################################################################### Utilities

function msg { out "$*" >&2 ;}
function err { local x=$? ; msg "$*" ; return $(( $x == 0 ? 1 : $x )) ;}
function out { printf '%s\n' "$*" ;}

# Handles "no-match" exit code specified by POSIX for filtering tools.
function maybe { "$@" || return $(( $? == 1 ? 0 : $? )) ;}


######################### Delegates to subcommands or runs main, as appropriate

main "$@"
