#!/bin/bash
set -o errexit -o nounset -o pipefail
function -h {
cat <<USAGE
 USAGE: pglite <db-to-use>?
               (--schema (<sql-file>|<directory>))*
               (--conf (<file>|<var>=<val>))*
               (--tcp)?
               <psql-arguments>* (-- <command> <arguments>*)?
        pglite setup <db-to-use>?
                     (--schema (<sql-file>|<directory>))*
                     (--conf (<file>|<var>=<val>))*
                     (--tcp)?
                     <initdb-arguments>*
        pglite rm <db-to-use>
        pglite url <db-to-use>?
        pglite (start | stop | status) <db-to-use>? <pgctl-arguments>*
        pglite connect <db-to-use>?
                       <psql-arguments>* (-- <command> <arguments>*)?
        pglite tmp ...

  Utility for managing ephemeral Postgres databases. The \`<db-to-use>\` can
  be specified by one of several options:

    (-d|--directory) <path>
    -h|--home                   $home
    -p|--project                ./$base, or nearest such directory
                                above this one (this is the default)

  When a command is passed, it is run in an environment where \`$DATABASE_URL\`
  is set to the database connection URL. The database connection information is
  made available through text replacement of arguments, as well:

    * The string {db} is replaced with the \`postgres://...\` URL.

    * The string {db.txt} is replaced with a path to a temporary file
      containing the connection string.

    * The string {jdbc.properties} is replaced with a path to a properties
      file containing the connection parameters in JAVA properties format.

  The \`pglite tmp\` subcommand is for databases that are to be used but one
  time, as in testing. It is very similar to the main command:

        pglite tmp (--schema (<sql-file>|<directory>))*
                   (--conf (<file>|<var>=<val>))*
                   (--tcp)?
                   <psql-arguments>* (-- <command> <arguments>*)?
        pglite tmp ((-r|--recent) | <token>)?
                   <psql-arguments>* (-- <command> <arguments>*)?
        pglite tmp ls
        pglite tmp setup (--schema (<sql-file>|<directory>))*
                         (--conf (<file>|<var>=<val>))*
                         (--tcp)?
                         <initdb-arguments>*
        pglite tmp rm ((-a|--all) | (-r|--recent) | <token>)?
        pglite tmp url ((-r|--recent) | <token>)
        pglite tmp (start | stop | status) <token>? <pgctl-arguments>*
        pglite tmp connect <token>?
                           <psql-arguments>* (-- <command> <arguments>*)?

 pglite setup

  Create the database directory.

 pglite url

  Obtain the Postgres URL for connecting (always a UNIX socket-based URL).

 pglite start|stop|status

  Start, stop or poll the status of the server.

 pglite connect

  Connect to the database, starting the server if it's not already started.

 pglite rm

  Remove the database directory and its configuration.

 -p|--personality pipeline|postgres

  Defaults to \`postgres\`. The \`pipeline\` personality exists to support
  PipelineDB.

 -d|--directory /path/to/data

  Defaults to \`$root\`.

USAGE
}; function --help { -h ;}                 # A nice way to handle -h and --help
export LC_ALL=en_US.UTF-8                    # A locale that works consistently

args=()
root=tmp/pglite
admin="$(whoami)"
role=lite
tcp=false
tmp=/tmp/pglite~"$(whoami)"

function main {
  local args=() personality=postgres
  while [[ $# -gt 0 ]]
  do
    case "$1" in
      start|stop|status) args+=( ctl "$1" ) ;;
      rm)                args+=( clean ) ;;
      -p|--personality)  personality="$2" ; shift ;;
      -d|--directory)    root="$2" ; shift ;;
      *)                 args+=( "$1" ) ;;
      --)                args+=( "$@" ) ; break ;;
    esac
    shift
  done

  set_personality "$personality"

  if [[ ${#args[@]} -gt 0 ]]
  then "${args[@]}"
  else setup && connect
  fi
}

# On some systems, `pg_ctl` &al are not on the default PATH.
function path_munger {
  for bin in /usr/lib/postgresql/*/bin
  do
    [[ -d $bin ]] || continue
    export PATH="$PATH":"$bin"
    break
  done
}

path_munger

# Database personality: names of administrative commands and files.
declare ctl=false sql=false init=false conf=/dev/null

function set_personality {
  case "$1" in
    postgres)
      ctl=pg_ctl
      sql=psql
      init=initdb
      conf=postgresql.conf ;;
    pipeline)
      ctl=pipeline-ctl
      sql=pipeline
      init=pipeline-init
      conf=pipelinedb.conf ;;
    *) msg "Unrecognized personality: $1"
       err 'Please choose from: pipeline postgres'
  esac
}

function load_personality {
  if [[ -f "$root"/personality ]]
  then set_personality "$(< "$root"/personality)"
  fi
}

function setup {
  if [[ -d "$root" ]]
  then msg "NB: Skipping setup; dir exists: $root"
  else initialize
  fi
}

function tmp {
  local appending=false cmd=()
  for arg in "$@"
  do
    if ! "$appending"
    then
      case "$arg" in
        --) appending=true ; continue ;;
        *)  err "Command to run should be passed as: -- cmd arg1 arg2 ..." ;;
      esac
    fi
    cmd+=( "$arg" )
  done
  tcp=true
  root="$tmp/$(date -u +%FT%TZ | tr -d :-).$$"
  setup > /dev/null            # Hide the log (it is stored in a file, anyways)
  local url="$(url)"
  ( msg "Database directory is: $root"
    msg "Reconnect with: pglite -d $root"
    msg "Setting DATABASE_URL=$url"
    export DATABASE_URL="$url"
    msg "Running: ${cmd[@]}"
    exec "${cmd[@]}" )
}

function connect {
  load_personality
  if ! is_running
  then
    ctl start -w
    trap finalize EXIT
  fi
  sql "$@"
}

function url {
  if [[ -s $root/url ]]
  then cat "$root"/url
  else out "postgres://$role@[$(absroot)]/$role"
  fi
}

function admin_url {
  if [[ -s $root/admin_url ]]
  then cat "$root"/admin_url
  else out "postgres://$admin@[$(absroot)]/template1"
  fi
}

function absroot {
  cd "$root" && pwd -P
}

function init_cluster_directory {
  "$init" -D "$root"/db -A trust --nosync --locale en_US.UTF-8

  # Use of include_dir limits this software to PG 9.3 and above.
  if ! egrep -q "^include_dir = 'conf.d'" "$root"/db/"$conf"
  then out "include_dir = 'conf.d'" >> "$root"/db/"$conf"
  fi

  mkdir -p "$root"/db/conf.d

  base_configuration > "$root"/db/conf.d/00.pglite.conf
  if "$tcp"
  then enable_tcp
  fi

  out "$personality" > "$root"/personality
}

function base_configuration {
# Use of unix_socket_directories limits this software to PG 9.3 and above.
cat <<EOF
unix_socket_directories = '"$(absroot)"'
listen_addresses = ''
datestyle = 'iso, ymd'
intervalstyle = 'iso_8601'
timezone = 'UTC'
EOF
}

function init_database_and_user {
sql_admin -v ON_ERROR_STOP=on <<SQL
CREATE ROLE "$role" WITH SUPERUSER LOGIN REPLICATION;
CREATE DATABASE "$role" WITH OWNER "$role";
SQL
}

function ctl {
  load_personality
  "$ctl" -D "$root"/db -l "$root"/log "$@"
}

function sql {
  "$sql" "$(url)" "$@"
}

function sql_admin {
  "$sql" "$(admin_url)"
}

function finalize {
  local code=$?
  ctl stop -m fast 2>/dev/null || true
  kill %1 2>/dev/null || true
  exit $code
}

function initialize {
  init_cluster_directory
  trap finalize EXIT
  touch "$root"/log
  tail -qF "$root"/log &
  ctl start -w
  init_database_and_user
  kill %1
  wait %1 2>/dev/null || true
}

function is_running {
  ctl status | fgrep -q 'server is running'
}

function clean {
  msg "Removing: $root"
  [[ ! -e "$root" ]] || rm -r "$root"
}

function enable_tcp {
  local port=
  port="$(random_free_tcp_port)"
  out "postgres://$role@localhost:$port/$role" > "$root"/url
  out "postgres://$admin@localhost:$port/template1" > "$root"/admin_url
  tcp_configuration "$port" > "$root"/db/conf.d/01.tcp.conf
}

function tcp_configuration {
# Use of unix_socket_directories limits this software to PG 9.3 and above.
cat <<EOF
listen_addresses = 'localhost'
port = $1
EOF
}

function random_free_tcp_port {
  local ports="${1:-1}" port="${2:-2048}" spacing=32
  local free_ports=( )
  local taken_ports=( $( netstat -aln | egrep ^tcp | fgrep LISTEN |
                         awk '{print $4}' | egrep -o '[0-9]+$' |
                         sort -n | uniq ) )

  port=$(( port + (RANDOM % spacing) ))

  for taken in "${taken_ports[@]}" 65535
  do
    while [[ $port -lt $taken && ${#free_ports[@]} -lt $ports ]]
    do
      free_ports+=( $port )
      port=$(( port + spacing + (RANDOM % spacing) ))
    done
    if [[ $port -lt $((taken + spacing)) ]]
    then port=$(( taken + spacing + (RANDOM % spacing) ))
    fi
  done

  [[ ${#free_ports[@]} -ge $ports ]] || return 2

  printf '%d\n' "${free_ports[@]}"
}


##################################################################### Utilities

function msg { out "$*" >&2 ;}
function err { local x=$? ; msg "$*" ; return $(( $x == 0 ? 1 : $x )) ;}
function out { printf '%s\n' "$*" ;}

# Handles "no-match" exit code specified by POSIX for filtering tools.
function maybe { "$@" || return $(( $? == 1 ? 0 : $? )) ;}


######################### Delegates to subcommands or runs main, as appropriate

main "$@"
